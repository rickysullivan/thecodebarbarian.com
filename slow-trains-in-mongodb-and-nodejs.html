<!DOCTYPE html><html><head><script type="text/javascript">var _sf_startpt=(new Date()).getTime()
</script><title>Slow Trains in MongoDB and Node.js | www.thecodebarbarian.com</title><meta name="viewport" content="width=device-width, initial-scale=1"><link href="//maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap.min.css" rel="stylesheet" type="text/css"><link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:200,300,400,600" rel="stylesheet" type="text/css"><link href="//fonts.googleapis.com/css?family=Merriweather:400,400italic,600,700" rel="stylesheet" type="text/css"><link href="//maxcdn.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet"><link href="/style/style.css" rel="stylesheet" type="text/css"><link href="/style/github.css" rel="stylesheet" type="text/css"><script href="http://code.jquery.com/jquery-2.1.1.min.js" type="text/javascript"></script><script href="//maxcdn.bootstrapcdn.com/bootstrap/3.2.0/js/bootstrap.min.js" type="text/javascript"></script><script href="/javascript/sidebar.js" type="text/javascript"></script><meta property="og:title" content="Slow Trains in MongoDB and Node.js"><meta property="og:url" content="http://www.thecodebarbarian.com/slow-trains-in-mongodb-and-nodejs"><meta property="og:image" content="https://s3.amazonaws.com/codebarbarian-images/20190506_train.jpeg"><meta property="og:site_name" content="The Code Barbarian"><meta property="description" content="When running MongoDB in production, you may see queries that should be fast, but instead are exceedingly slow. For example, my Node.js apps have seen a [`findOne()`](http://mongodb.github.io/node-mongodb-native/3.1/api/Collection.html#findOne) on a collection with only 1 document take over 1 _second_."><meta name="twitter:image" content="https://s3.amazonaws.com/codebarbarian-images/20190506_train.jpeg"></head><body><div class="navbar social-links hidden-sm hidden-xs"><div class="container"><ul class="nav navbar-nav navbar-right"><li><a href="http://www.twitter.com/code_barbarian">twitter</a></li><li><a href="http://www.github.com/vkarpov15">github</a></li><li><a href="http://thecodebarbarian.com/feed.xml">rss</a></li><li><a href="/recommendations">recommendations</a></li></ul></div></div><div class="navbar" id="nav"><div class="container"><div class="navbar-header"><a class="navbar-brand big-brand" href="http://thecodebarbarian.com"><img class="logo" src="/images/Barbarian_Head.png"><span class="site-name">The Code Barbarian</span></a></div><div class="navbar-right collapse navbar-collapse" id="home-nav-mobile"><ul class="nav navbar-nav"><li><a href="/tag/mongodb.html">MongoDB</a></li><li><a href="/tag/nodejs.html">NodeJS</a></li><li><a href="/tag/asyncawait.html">Async/Await</a></li><li><a href="/tag/vue.html">Vue</a></li><li class="hidden-md hidden-lg"><a href="#">@code_barbarian</a></li><li class="hidden-md hidden-lg"><a href="#">TCB Github</a></li><li class="hidden-md hidden-lg"><a href="#">TCB Facebook</a></li></ul></div></div></div><div class="container-fluid"><div class="col-lg-3 col-lg-offset-9 right-bar" id="desktop-right-bar"><div class="right-bar-content-slider pull-right"><div class="row recent-posts right-bar-group"><div class="col-lg-12 articles"><p class="right-bar-label">Most Popular Articles</p><ul class="list-unstyled"><li class="right-bar-li"><a href="/common-async-await-design-patterns-in-node.js.html">Common Async/Await Design Patterns in Node.js</a></li><li class="right-bar-li"><a href="/unhandled-promise-rejections-in-node.js.html">Unhandled Promise Rejections in Node.js</a></li><li class="right-bar-li"><a href="/using-async-await-with-mocha-express-and-mongoose">Using Async/Await with Mocha, Express, and Mongoose</a></li><li class="right-bar-li"><a href="/write-your-own-node-js-promise-library-from-scratch.html">Write Your Own Node.js Promise Library from Scratch</a></li><li class="right-bar-li"><a href="/80-20-guide-to-express-error-handling">The 80/20 Guide to Express Error Handling</a></li></ul></div></div><div class="row recent-posts right-bar-group"><div class="col-lg-12 books"><p class="right-bar-label">Ebooks<div><a href="http://asyncawait.net/?utm_source=thecodebarbarian&amp;utm_campaign=sidebar"><img src="/images/verticalbanner.png"></a></div><div><a href="http://es2015generators.com"><img src="https://i.imgur.com/xvGNKlr.png"><p><i>The 80/20 Guide to ES2015 Generators</i></p></a></div></p></div></div></div></div></div><div class="container-fluid hidden-sm hidden-md hidden-lg" id="mobile-sharing-options"><div class="row"><div class="col-lg-12"><style>#home-nav-mobile {
  float: left !important;
  margin-left: 215px !important;
}
</style><div class="post-sharing-options"><div class="row"><div class="col-xs-3 twitter-share sharing-option"><a class="social" href="https://twitter.com/share?url=#{encodeURIComponent('http://www.thecodebarbarian.com' + post.dest.directory.substr('./bin'.length) + '/' + post.dest.name)}&amp;via=code_barbarian"><i class="fa fa-twitter"></i></a></div><div class="col-xs-3 facebook-share sharing-option"><a class="social" href="https://www.facebook.com/sharer/sharer.php?u=#{encodeURIComponent('http://www.thecodebarbarian.com/' + post.dest.directory.substr('./bin'.length) + '/' + post.dest.name)}"><i class="fa fa-facebook"></i></a></div><div class="col-xs-3 google-share sharing-option"><a class="social" href="https://plus.google.com/share?url=#{encodeURIComponent('http://www.thecodebarbarian.com/' + post.dest.directory.substr('./bin'.length) + '/' + post.dest.name)}"><i class="fa fa-google-plus"></i></a></div><div class="col-xs-3 comment sharing-option"><a class="social" href="#disqus_thread"><i class="fa fa-comment"></i></a></div></div></div></div></div></div><div class="post-sharing-options hidden-xs pull-left" id="desktop-sharing-options"><ul class="list-unstyled"><li class="twitter-share"><a class="social" href="https://twitter.com/share?url=#{encodeURIComponent('http://www.thecodebarbarian.com' + post.dest.directory.substr('./bin'.length) + '/' + post.dest.name)}&amp;via=code_barbarian"><i class="fa fa-twitter sharing-option"></i></a></li><li class="facebook-share"><a class="social" href="https://www.facebook.com/sharer/sharer.php?u=#{encodeURIComponent('http://www.thecodebarbarian.com/' + post.dest.directory.substr('./bin'.length) + '/' + post.dest.name)}"><i class="fa fa-facebook sharing-option"></i></a></li><li class="google-share"><a class="social" href="https://plus.google.com/share?url=#{encodeURIComponent('http://www.thecodebarbarian.com/' + post.dest.directory.substr('./bin'.length) + '/' + post.dest.name)}"><i class="fa fa-google-plus sharing-option"></i></a></li></ul></div><div class="container"><div class="col-lg-9 post-text"><div class="row"><div class="title-byline-container"><h1 class="post-title">Slow Trains in MongoDB and Node.js</h1><div class="credits"><span class="byline">by Valeri Karpov</span><span class="byhandle"><a href="http://www.twitter.com/code_barbarian">@code_barbarian</a></span><span class="bydate">May 06, 2019</span></div></div></div><script type="text/javascript" src="/js/native.js"></script><div><script src="//m.servedby-buysellads.com/monetization.js" type="text/javascript"></script>

<div class="native-banner"></div>
</div><script async type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CKYI5K3Y&placement=thecodebarbariancom" id="_carbonads_js"></script><div class="post-body-text-container"><p>When running MongoDB in production, you may see queries that should be fast, but instead are exceedingly slow. For example, my Node.js apps have seen a <a href="http://mongodb.github.io/node-mongodb-native/3.1/api/Collection.html#findOne"><code>findOne()</code></a> on a collection with only 1 document take over 1 <em>second</em>.</p>
<p>There&#39;s a simple explanation for this phenomenon: a MongoDB server can <a href="http://mongodb.github.io/node-mongodb-native/2.0/reference/faq/#how-can-i-avoid-a-very-slow-operation-delaying-other-operations">only execute a single operation on a given socket at a time</a>. In other words, the number of concurrent operations your Node.js connection can handle is limited by the <code>poolSize</code> option. For example, the 2nd query below will take approximately 1 second, because <code>poolSize = 1</code> and it is blocked by a slow query.</p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> mongodb = <span class="hljs-built_in">require</span>(<span class="hljs-string">'mongodb'</span>)

run().catch(error =&gt; <span class="hljs-built_in">console</span>.log(error));

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">run</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> db = <span class="hljs-keyword">await</span> mongodb.MongoClient.
    connect(<span class="hljs-string">'mongodb://localhost:27017/test'</span>, {
      useNewUrlParser: <span class="hljs-literal">true</span>,
      poolSize: <span class="hljs-number">1</span> <span class="hljs-comment">// Only 1 operation can run at a time</span>
    }).
    then(client =&gt; client.db());

  <span class="hljs-keyword">await</span> db.dropDatabase();
  <span class="hljs-keyword">await</span> db.collection(<span class="hljs-string">'Test'</span>).insertOne({ answer: <span class="hljs-number">42</span> });

  <span class="hljs-comment">// First, run a slow query that will take about 1 sec, but don't `await` on it. Instead,</span>
  <span class="hljs-comment">// continue so we can execute a 2nd query a little later.</span>
  <span class="hljs-keyword">const</span> promise = db.collection(<span class="hljs-string">'Test'</span>).find({ $where: <span class="hljs-string">'sleep(1000) || true'</span> }).toArray();

  <span class="hljs-comment">// Run a 2nd query that _should_ be fast</span>
  <span class="hljs-keyword">const</span> startTime = <span class="hljs-built_in">Date</span>.now();
  <span class="hljs-keyword">await</span> db.collection(<span class="hljs-string">'Test'</span>).findOne();

  <span class="hljs-comment">// Will print something like "Executed query in 1031 ms"</span>
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Executed query in'</span>, <span class="hljs-built_in">Date</span>.now() - startTime, <span class="hljs-string">'ms'</span>);
}</code></pre>
<p>You can visualize this by imagining <code>db</code> as a set of <code>poolSize</code> train tracks. If there&#39;s only 1 track and a slow, overburdened cargo train takes 1 second to clear the track, the bullet train behind it needs to wait.</p>
<p>In general, there are 5 methods I&#39;ve used to minimize the impact of slow trains:</p>
<p>1) Increase <code>poolSize</code></p>
<p>2) Separate connection pools for potentially slow operations</p>
<p>3) Break up one slow operation into many fast operations</p>
<p>4) Indexes</p>
<p>5) <a href="https://docs.mongodb.com/manual/reference/operator/meta/maxTimeMS/">The <code>maxTimeMS</code> option</a></p>
<h2 id="increase-poolsize">Increase <code>poolSize</code></h2>
<p>Increasing <code>poolSize</code> is a one-liner in both the <a href="http://mongodb.github.io/node-mongodb-native/3.1/api/MongoClient.html">MongoDB Node.js driver</a> and <a href="https://mongoosejs.com/docs/connections.html#options">Mongoose</a>. <code>poolSize = 1</code> is good for experimenting with the slow train problem, but in production you should use at least the default <code>poolSize = 5</code>. Below is an example with <code>poolSize = 10</code>.</p>
<pre><code class="language-javascript">  <span class="hljs-keyword">const</span> db = <span class="hljs-keyword">await</span> mongodb.MongoClient.
    connect(<span class="hljs-string">'mongodb://localhost:27017/test'</span>, {
      useNewUrlParser: <span class="hljs-literal">true</span>,
      poolSize: <span class="hljs-number">10</span> <span class="hljs-comment">// Can now run 10 operations at a time</span>
    }).
    then(client =&gt; client.db());

  <span class="hljs-keyword">await</span> db.dropDatabase();
  <span class="hljs-keyword">await</span> db.collection(<span class="hljs-string">'Test'</span>).insertOne({ answer: <span class="hljs-number">42</span> });

  <span class="hljs-keyword">const</span> promise = db.collection(<span class="hljs-string">'Test'</span>).find({ $where: <span class="hljs-string">'sleep(1000) || true'</span> }).toArray();

  <span class="hljs-keyword">const</span> startTime = <span class="hljs-built_in">Date</span>.now();
  <span class="hljs-keyword">await</span> db.collection(<span class="hljs-string">'Test'</span>).findOne();

  <span class="hljs-comment">// Will print something like "Executed query in 4 ms"</span>
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Executed query in'</span>, <span class="hljs-built_in">Date</span>.now() - startTime, <span class="hljs-string">'ms'</span>);</code></pre>
<p>However, too many connections can cause performance issues and can cause you to <a href="https://stackoverflow.com/questions/16713415/mongodb-increasing-max-connections-in-mongodb">hit OS-level resource limits</a>. So increasing <code>poolSize</code> to 10k is most likely a bad idea. In production, I generally use <code>poolSize = 10</code>.</p>
<h2 id="separate-connection-pools-for-potentially-slow-operations">Separate Connection Pools for Potentially Slow Operations</h2>
<p>Increasing <code>poolSize</code> won&#39;t help if you get a large batch of slow queries all at once. But what can help is separate connection pools for operations that are performance sensitive versus operations that can be slow. For example, in the below example there&#39;s two connections <code>db1</code> and <code>db2</code>. A slow query on <code>db1</code> doesn&#39;t block MongoDB from responding to a fast query on <code>db2</code>.</p>
<pre><code class="language-javascript">  <span class="hljs-comment">// First connection for slow operations</span>
  <span class="hljs-keyword">const</span> db1 = <span class="hljs-keyword">await</span> mongodb.MongoClient.
    connect(<span class="hljs-string">'mongodb://localhost:27017/test'</span>, {
      useNewUrlParser: <span class="hljs-literal">true</span>,
      poolSize: <span class="hljs-number">1</span> <span class="hljs-comment">// Only 1 operation can run at a time</span>
    }).
    then(client =&gt; client.db());

  <span class="hljs-comment">// 2nd connection for fast operations</span>
  <span class="hljs-keyword">const</span> db2 = <span class="hljs-keyword">await</span> mongodb.MongoClient.
    connect(<span class="hljs-string">'mongodb://localhost:27017/test'</span>, {
      useNewUrlParser: <span class="hljs-literal">true</span>,
      poolSize: <span class="hljs-number">1</span> <span class="hljs-comment">// Only 1 operation can run at a time</span>
    }).
    then(client =&gt; client.db());

  <span class="hljs-keyword">await</span> db1.dropDatabase();
  <span class="hljs-keyword">await</span> db1.collection(<span class="hljs-string">'Test'</span>).insertOne({ answer: <span class="hljs-number">42</span> });

  <span class="hljs-comment">// Run a slow query on the 1st connection `db1`</span>
  <span class="hljs-keyword">const</span> promise = db1.collection(<span class="hljs-string">'Test'</span>).find({ $where: <span class="hljs-string">'sleep(1000) || true'</span> }).toArray();

  <span class="hljs-comment">// Run a 2nd query on the 2nd connection `db2`</span>
  <span class="hljs-keyword">const</span> startTime = <span class="hljs-built_in">Date</span>.now();
  <span class="hljs-keyword">await</span> db2.collection(<span class="hljs-string">'Test'</span>).findOne();

  <span class="hljs-comment">// Will print something like "Executed query in 4 ms"</span>
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Executed query in'</span>, <span class="hljs-built_in">Date</span>.now() - startTime, <span class="hljs-string">'ms'</span>);</code></pre>
<h2 id="break-up-one-slow-operation-into-many-fast-operations">Break Up One Slow Operation Into Many Fast Operations</h2>
<p><a href="https://docs.mongodb.com/manual/aggregation/">MongoDB aggregations</a> count as a single operation. Because the aggregation framework is so expressive, many people end up creating exceedingly complex aggregations that end up causing slow trains in production.</p>
<p>In general, if you have an aggregation that&#39;s causing slow trains in production, you should consider replacing the aggregation with Node.js logic that relies on <code>find()</code>. For example, you could replace <a href="https://docs.mongodb.com/manual/reference/operator/aggregation/lookup/"><code>$lookup</code></a> with <a href="https://mongoosejs.com/docs/populate.html">Mongoose populate</a>.</p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> mongodb = <span class="hljs-built_in">require</span>(<span class="hljs-string">'mongodb'</span>)

run().catch(error =&gt; <span class="hljs-built_in">console</span>.log(error));

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">run</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> db = <span class="hljs-keyword">await</span> mongodb.MongoClient.
    connect(<span class="hljs-string">'mongodb://localhost:27017/test'</span>, {
      useNewUrlParser: <span class="hljs-literal">true</span>,
      poolSize: <span class="hljs-number">1</span> <span class="hljs-comment">// Only 1 operation can run at a time</span>
    }).
    then(client =&gt; client.db());

  <span class="hljs-keyword">await</span> db.dropDatabase();

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; ++i) {
    <span class="hljs-keyword">await</span> db.collection(<span class="hljs-string">'Foo'</span>).insertOne({ _id: i });
  }
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Inserted foo docs'</span>);

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; ++i) {
    <span class="hljs-keyword">await</span> db.collection(<span class="hljs-string">'Bar'</span>).insertOne({ _id: i, fooId: i });
  }
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Inserted bar docs'</span>);

  <span class="hljs-comment">// This aggregation will be exceedingly slow because there's no index on</span>
  <span class="hljs-comment">// `fooId`. Instead, could replace this with Mongoose populate, which would</span>
  <span class="hljs-comment">// replace this aggregation into 2 faster `find()` operations.</span>
  <span class="hljs-keyword">const</span> promise = db.collection(<span class="hljs-string">'Foo'</span>).aggregate([
    { $lookup: { <span class="hljs-keyword">from</span>: <span class="hljs-string">'Bar'</span>, localField: <span class="hljs-string">'_id'</span>, foreignField: <span class="hljs-string">'fooId'</span>, <span class="hljs-keyword">as</span>: <span class="hljs-string">'bars'</span> } }
  ]).toArray();

  <span class="hljs-keyword">const</span> startTime = <span class="hljs-built_in">Date</span>.now();
  <span class="hljs-keyword">await</span> db.collection(<span class="hljs-string">'Test'</span>).findOne();

  <span class="hljs-comment">// "Executed query in 301 ms"</span>
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Executed query in'</span>, <span class="hljs-built_in">Date</span>.now() - startTime, <span class="hljs-string">'ms'</span>);
}</code></pre>
<h2 id="indexes">Indexes</h2>
<p><a href="https://docs.mongodb.com/manual/indexes/">MongoDB indexes</a> are a complex subject, but for the purposes of this article the idea is simple: make a slow query fast. For example, you can speed up the <code>$lookup</code> aggregation above using an index on <code>fooId</code>.</p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> mongodb = <span class="hljs-built_in">require</span>(<span class="hljs-string">'mongodb'</span>)

run().catch(error =&gt; <span class="hljs-built_in">console</span>.log(error));

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">run</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> db = <span class="hljs-keyword">await</span> mongodb.MongoClient.
    connect(<span class="hljs-string">'mongodb://localhost:27017/test'</span>, {
      useNewUrlParser: <span class="hljs-literal">true</span>,
      poolSize: <span class="hljs-number">1</span> <span class="hljs-comment">// Only 1 operation can run at a time</span>
    }).
    then(client =&gt; client.db());

  <span class="hljs-keyword">await</span> db.dropDatabase();

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; ++i) {
    <span class="hljs-keyword">await</span> db.collection(<span class="hljs-string">'Foo'</span>).insertOne({ _id: i });
  }
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Inserted foo docs'</span>);

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; ++i) {
    <span class="hljs-keyword">await</span> db.collection(<span class="hljs-string">'Bar'</span>).insertOne({ _id: i, fooId: i });
  }
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Inserted bar docs'</span>);

  <span class="hljs-comment">// Create an index on `fooId` before executing the query</span>
  <span class="hljs-keyword">await</span> db.collection(<span class="hljs-string">'Bar'</span>).createIndex({ fooId: <span class="hljs-number">1</span> });
  <span class="hljs-keyword">const</span> promise = db.collection(<span class="hljs-string">'Foo'</span>).aggregate([
    { $lookup: { <span class="hljs-keyword">from</span>: <span class="hljs-string">'Bar'</span>, localField: <span class="hljs-string">'_id'</span>, foreignField: <span class="hljs-string">'fooId'</span>, <span class="hljs-keyword">as</span>: <span class="hljs-string">'bars'</span> } }
  ]).toArray();

  <span class="hljs-keyword">const</span> startTime = <span class="hljs-built_in">Date</span>.now();
  <span class="hljs-keyword">await</span> db.collection(<span class="hljs-string">'Test'</span>).findOne();

  <span class="hljs-comment">// "Executed query in 19 ms"</span>
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Executed query in'</span>, <span class="hljs-built_in">Date</span>.now() - startTime, <span class="hljs-string">'ms'</span>);
}</code></pre>
<h2 id="the-maxtimems-option">The <code>maxTimeMS</code> Option</h2>
<p>The <a href="https://docs.mongodb.com/manual/reference/operator/meta/maxTimeMS/"><code>maxTimeMS</code> option</a> tells the MongoDB server to stop running a query after a certain period of time. In the below example, the slow <code>aggregate()</code> call will throw an error after approximately 10ms. Because the MongoDB server stops executing the slow aggregation after 10ms, it unblocks the fast <code>findOne()</code>.</p>
<pre><code class="language-javascript">  <span class="hljs-keyword">const</span> db = <span class="hljs-keyword">await</span> mongodb.MongoClient.
    connect(<span class="hljs-string">'mongodb://localhost:27017/test'</span>, {
      useNewUrlParser: <span class="hljs-literal">true</span>,
      poolSize: <span class="hljs-number">1</span> <span class="hljs-comment">// Only 1 operation can run at a time</span>
    }).
    then(client =&gt; client.db());

  <span class="hljs-keyword">await</span> db.dropDatabase();

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; ++i) {
    <span class="hljs-keyword">await</span> db.collection(<span class="hljs-string">'Foo'</span>).insertOne({ _id: i });
  }
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Inserted foo docs'</span>);

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; ++i) {
    <span class="hljs-keyword">await</span> db.collection(<span class="hljs-string">'Bar'</span>).insertOne({ _id: i, fooId: i });
  }
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Inserted bar docs'</span>);

  <span class="hljs-comment">// This aggregation will fail if it doesn't finish within 10ms</span>
  <span class="hljs-keyword">const</span> promise = db.collection(<span class="hljs-string">'Foo'</span>).
    aggregate(
      [{ $lookup: { <span class="hljs-keyword">from</span>: <span class="hljs-string">'Bar'</span>, localField: <span class="hljs-string">'_id'</span>, foreignField: <span class="hljs-string">'fooId'</span>, <span class="hljs-keyword">as</span>: <span class="hljs-string">'bars'</span> } }],
      { maxTimeMS: <span class="hljs-number">10</span> }
    ).
    toArray().
    <span class="hljs-keyword">catch</span>(err =&gt; {}); <span class="hljs-comment">// Ignore maxTimeMS error</span>

  <span class="hljs-keyword">const</span> startTime = <span class="hljs-built_in">Date</span>.now();
  <span class="hljs-keyword">await</span> db.collection(<span class="hljs-string">'Test'</span>).findOne();

  <span class="hljs-comment">// "Executed query in 19 ms"</span>
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Executed query in'</span>, <span class="hljs-built_in">Date</span>.now() - startTime, <span class="hljs-string">'ms'</span>);</code></pre>
<p>One nice detail of <code>maxTimeMS</code> is that it does <strong>not</strong> count time spent blocked behind a slow train. In other words, if you run a <code>find()</code> with <code>maxTimeMS = 100</code>, and that <code>find()</code> spends 500ms blocked behind a slow query and then executes in 50ms, you won&#39;t see an error, even though your Node.js process waited 550ms for the query. This means <code>maxTimeMS</code> helps you find queries that are actually slow, as opposed to queries that appear slow because they&#39;re blocked by other slow queries.</p>
<h2 id="moving-on">Moving On</h2>
<p>Slow trains in MongoDB may seem like a major limitation, but this behavior has some benefits. Many other databases have similar limits built in, like <a href="https://planet.mysql.com/entry/?id=29516"><code>max_concurrent_queries</code> in MySQL</a>, because too many concurrent queries can also lead to performance issues. The guidelines in this article have helped me keep API instances running smoothly even with <code>poolSize = 10</code>, try them out and please discuss in the comments section.</p>
<p><em>Want to become your team&#39;s MongoDB expert? &quot;Mastering Mongoose&quot; distills 8 years of hard-earned lessons building Mongoose apps at scale into 153 pages. That means you can learn what you need to know to build production-ready full-stack apps with Node.js and MongoDB in a few days. <a href="https://masteringjs.io/ebooks/mastering-mongoose">Get your copy</a>!</em></p>
<a href="https://masteringjs.io/ebooks/mastering-mongoose" class="async-await-banner">
  <img src="https://masteringjs.io/ebooks/mastering-mongoose-horizontal.png">
</a></div><div style="color: #666666; border-top: 1px dashed #666666; margin: 25px; text-align: center; padding-top: 10px"><em>Found a typo or error? Open up a pull request! This post is
available as markdown on&nbsp;<a href="https://github.com/vkarpov15/thecodebarbarian.com/blob/master/lib/posts/#{post.src.substr('./lib/posts/'.length)}">Github</a></em></div><div id="disqus_thread"></div><script type="text/javascript">/* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
var disqus_shortname = 'codebarbarian'; // required: replace example with your forum shortname

/* * * DON'T EDIT BELOW THIS LINE * * */
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript><a class="dsq-brlink" href="http://disqus.com">comments powered by <span class="logo-disqus">Disqus</span></a></div></div><div style="padding-bottom: 100px">&nbsp;</div><script type="text/javascript">var xhr = new XMLHttpRequest();
xhr.open('POST', 'https://g0a3nbw0xa.execute-api.us-east-1.amazonaws.com/prod/track', true);
xhr.setRequestHeader('Content-Type', 'application/json');
xhr.onreadystatechange = function() {};
xhr.send(JSON.stringify({
  path: window.location.pathname,
  hostname: window.location.hostname
}));</script><link rel="stylesheet" href="/style/inlinecpc.css"></body></html>