<!DOCTYPE html><html><head><script type="text/javascript">var _sf_startpt=(new Date()).getTime()</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-TE4SWRGR9E"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());

gtag('config', 'G-TE4SWRGR9E');
</script><title>A Node.js Perspective on MongoDB 3.4: $facet | www.thecodebarbarian.com</title><meta name="viewport" content="width=device-width, initial-scale=1"><link href="//maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap.min.css" rel="stylesheet" type="text/css"><link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:200,300,400,600" rel="stylesheet" type="text/css"><link href="//fonts.googleapis.com/css?family=Merriweather:400,400italic,600,700" rel="stylesheet" type="text/css"><link href="//maxcdn.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet"><link href="/style/style.css" rel="stylesheet" type="text/css"><link href="/style/github.css" rel="stylesheet" type="text/css"><script href="http://code.jquery.com/jquery-2.1.1.min.js" type="text/javascript"></script><script href="//maxcdn.bootstrapcdn.com/bootstrap/3.2.0/js/bootstrap.min.js" type="text/javascript"></script><script href="/javascript/sidebar.js" type="text/javascript"></script><meta property="og:title" content="A Node.js Perspective on MongoDB 3.4: $facet"><meta property="og:url" content="http://www.thecodebarbarian.com/a-nodejs-perspective-on-mongodb-34-facet"><meta property="og:image" content="http://i.imgur.com/U4G4pxc.png"><meta property="og:site_name" content="The Code Barbarian"><meta property="description" content="[MongoDB 3.4](https://docs.mongodb.com/manual/release-notes/3.4/)"><meta name="twitter:image" content="http://i.imgur.com/U4G4pxc.png"></head><body><div class="navbar social-links hidden-sm hidden-xs"><div class="container"><ul class="nav navbar-nav navbar-right"><li><a href="http://www.twitter.com/code_barbarian">twitter</a></li><li><a href="http://www.github.com/vkarpov15">github</a></li><li><a href="http://thecodebarbarian.com/feed.xml">rss</a></li><li><a href="/recommendations">recommendations</a></li></ul></div></div><div class="navbar" id="nav"><div class="container"><div class="navbar-header"><a class="navbar-brand big-brand" href="http://thecodebarbarian.com"><img class="logo" src="/images/Barbarian_Head.png"><span class="site-name">The Code Barbarian</span></a></div><div class="navbar-right collapse navbar-collapse" id="home-nav-mobile"><ul class="nav navbar-nav"><li><a href="/tag/mongodb.html">MongoDB</a></li><li><a href="/tag/nodejs.html">NodeJS</a></li><li><a href="/tag/asyncawait.html">Async/Await</a></li><li><a href="/tag/vue.html">Vue</a></li><li class="hidden-md hidden-lg"><a href="#">@code_barbarian</a></li><li class="hidden-md hidden-lg"><a href="#">TCB Github</a></li><li class="hidden-md hidden-lg"><a href="#">TCB Facebook</a></li></ul></div></div></div><div class="container-fluid"><div class="col-lg-3 col-lg-offset-9 right-bar" id="desktop-right-bar"><div class="right-bar-content-slider pull-right"><div class="row recent-posts right-bar-group"><div class="col-lg-12 articles"><p class="right-bar-label">Most Popular Articles</p><ul class="list-unstyled"><li class="right-bar-li"><a href="/common-async-await-design-patterns-in-node.js.html">Common Async/Await Design Patterns in Node.js</a></li><li class="right-bar-li"><a href="/unhandled-promise-rejections-in-node.js.html">Unhandled Promise Rejections in Node.js</a></li><li class="right-bar-li"><a href="/using-async-await-with-mocha-express-and-mongoose">Using Async/Await with Mocha, Express, and Mongoose</a></li><li class="right-bar-li"><a href="/write-your-own-node-js-promise-library-from-scratch.html">Write Your Own Node.js Promise Library from Scratch</a></li><li class="right-bar-li"><a href="/80-20-guide-to-express-error-handling">The 80/20 Guide to Express Error Handling</a></li></ul></div></div><div class="row recent-posts right-bar-group"><div class="col-lg-12 books"><p class="right-bar-label">Ebooks<div><a href="http://asyncawait.net/?utm_source=thecodebarbarian&amp;utm_campaign=sidebar"><img src="/images/verticalbanner.png"></a></div><div><a href="http://es2015generators.com"><img src="https://i.imgur.com/xvGNKlr.png"><p><i>The 80/20 Guide to ES2015 Generators</i></p></a></div></p></div></div></div></div></div><div class="container-fluid hidden-sm hidden-md hidden-lg" id="mobile-sharing-options"><div class="row"><div class="col-lg-12"><style>#home-nav-mobile {
  float: left !important;
  margin-left: 215px !important;
}
</style><div class="post-sharing-options"><div class="row"><div class="col-xs-3 twitter-share sharing-option"><a class="social" href="https://twitter.com/share?url=#{encodeURIComponent('http://www.thecodebarbarian.com' + post.dest.directory.substr('./bin'.length) + '/' + post.dest.name)}&amp;via=code_barbarian"><i class="fa fa-twitter"></i></a></div><div class="col-xs-3 facebook-share sharing-option"><a class="social" href="https://www.facebook.com/sharer/sharer.php?u=#{encodeURIComponent('http://www.thecodebarbarian.com/' + post.dest.directory.substr('./bin'.length) + '/' + post.dest.name)}"><i class="fa fa-facebook"></i></a></div><div class="col-xs-3 google-share sharing-option"><a class="social" href="https://plus.google.com/share?url=#{encodeURIComponent('http://www.thecodebarbarian.com/' + post.dest.directory.substr('./bin'.length) + '/' + post.dest.name)}"><i class="fa fa-google-plus"></i></a></div><div class="col-xs-3 comment sharing-option"><a class="social" href="#disqus_thread"><i class="fa fa-comment"></i></a></div></div></div></div></div></div><div class="post-sharing-options hidden-xs pull-left" id="desktop-sharing-options"><ul class="list-unstyled"><li class="twitter-share"><a class="social" href="https://twitter.com/share?url=#{encodeURIComponent('http://www.thecodebarbarian.com' + post.dest.directory.substr('./bin'.length) + '/' + post.dest.name)}&amp;via=code_barbarian"><i class="fa fa-twitter sharing-option"></i></a></li><li class="facebook-share"><a class="social" href="https://www.facebook.com/sharer/sharer.php?u=#{encodeURIComponent('http://www.thecodebarbarian.com/' + post.dest.directory.substr('./bin'.length) + '/' + post.dest.name)}"><i class="fa fa-facebook sharing-option"></i></a></li><li class="google-share"><a class="social" href="https://plus.google.com/share?url=#{encodeURIComponent('http://www.thecodebarbarian.com/' + post.dest.directory.substr('./bin'.length) + '/' + post.dest.name)}"><i class="fa fa-google-plus sharing-option"></i></a></li></ul></div><div class="container"><div class="col-lg-9 post-text"><div class="row"><div class="title-byline-container"><h1 class="post-title">A Node.js Perspective on MongoDB 3.4: $facet</h1><div class="credits"><span class="byline">by Valeri Karpov</span><span class="byhandle"><a href="http://www.twitter.com/code_barbarian">@code_barbarian</a></span><span class="bydate">January 19, 2017</span></div></div></div><script type="text/javascript" src="/js/native.js"></script><div><script src="//m.servedby-buysellads.com/monetization.js" type="text/javascript"></script>

<div class="native-banner"></div>
</div><script async type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CKYI5K3Y&placement=thecodebarbariancom" id="_carbonads_js"></script><div class="post-body-text-container"><p><a href="https://docs.mongodb.com/manual/release-notes/3.4/">MongoDB 3.4</a>
has <a href="https://docs.mongodb.com/manual/release-notes/3.4/#aggregation">27 new aggregation concepts</a>.
Last week I covered the new <a href="http://thecodebarbarian.com/a-nodejs-perspective-on-mongodb-34-graphlookup.html"><code>$graphLookup</code> stage</a>, which recursively searches collections. This week I&#39;ll cover the new <a href="https://docs.mongodb.com/v3.4/reference/operator/aggregation/facet/"><code>$facet</code> stage</a> and
the related <a href="https://docs.mongodb.com/manual/reference/operator/aggregation/bucket/"><code>$bucket</code></a> and <a href="https://docs.mongodb.com/v3.4/reference/operator/aggregation/bucketAuto/"><code>$bucketAuto</code></a> operators. These new features are tailor-made for building powerful product search pages, and will quickly become your favorite aggregation features if you&#39;re working on
an ecommerce product.</p>
<h2 id="what-is-faceted-search">What is Faceted Search?</h2>
<p>Here&#39;s the view you see when searching for products on Amazon:</p>
<p><a href="http://i.imgur.com/JXjcuZn.png"><img src="http://i.imgur.com/JXjcuZn.png" width="300"></a></p>
<p>The &quot;Refine By&quot; menu on the left is a classic example of faceted search. When you
only want to see products that are eligible for Amazon prime, the counts in
the &quot;Refine By&quot; menu update to only reflect products that are eligible for Prime.
For example, there are 26 products in the $10-$25 range, but only 7 of those
are eligible for Prime.</p>
<p><a href="http://i.imgur.com/jkRdMh0.png"><img src="http://i.imgur.com/jkRdMh0.png" width="300"></a></p>
<p>Updating these counts in a sane and performant way was a huge pain before
MongoDB 3.4. Your options were to either <a href="https://www.mongodb.com/blog/post/faceted-search-with-mongodb">re-structure your data specifically for faceted search</a> or execute a separate aggregation for every single individual &quot;facet&quot; you want to
filter by.</p>
<p>Let&#39;s take a look at a more concrete example. Here&#39;s a collection of 4 books:</p>
<pre><code class="language-javascript">db.books.insertMany([
  {
    title: <span class="hljs-string">'Professional AngularJS'</span>,
    author: <span class="hljs-string">'Valeri Karpov'</span>,
    price: <span class="hljs-number">37</span>,
    year: <span class="hljs-number">2015</span>,
    tags: [<span class="hljs-string">'JavaScript'</span>, <span class="hljs-string">'AngularJS'</span>]
  },
  {
    title: <span class="hljs-string">'The 80/20 Guide To ES2015 Generators'</span>,
    author: <span class="hljs-string">'Valeri Karpov'</span>,
    price: <span class="hljs-number">10</span>,
    year: <span class="hljs-number">2016</span>,
    tags: [<span class="hljs-string">'JavaScript'</span>, <span class="hljs-string">'ES6'</span>]
  },
  {
    title: <span class="hljs-string">'Total Recall: My Unbelievably True Life Story'</span>,
    author: <span class="hljs-string">'Arnold Schwarzenegger'</span>,
    price: <span class="hljs-number">32</span>,
    year: <span class="hljs-number">2013</span>,
    tags: [<span class="hljs-string">'Biography'</span>]
  },
  {
    title: <span class="hljs-string">"Arnold's Bodybuilding for Men"</span>,
    author: <span class="hljs-string">'Arnold Schwarzenegger'</span>,
    price: <span class="hljs-number">14</span>,
    year: <span class="hljs-number">1984</span>,
    tags: [<span class="hljs-string">'Fitness'</span>]
  }
]);</code></pre>
<p>In order to enable faceted search by year, you need to run an aggregation query
that buckets books by the year they were published.</p>
<pre><code class="language-javascript">db.books.aggregate([
  <span class="hljs-comment">// Count the number of books published in a given year</span>
  {
    $group: {
      _id: <span class="hljs-string">'$year'</span>,
      count: { $sum: <span class="hljs-number">1</span> }
    }
  },
  <span class="hljs-comment">// Sort by year descending</span>
  { $sort: { count: <span class="hljs-number">-1</span>, _id: <span class="hljs-number">-1</span> } }
]);

<span class="hljs-comment">// Output</span>
{ <span class="hljs-string">"_id"</span> : <span class="hljs-number">2016</span>, <span class="hljs-string">"count"</span> : <span class="hljs-number">1</span> }
{ <span class="hljs-string">"_id"</span> : <span class="hljs-number">2015</span>, <span class="hljs-string">"count"</span> : <span class="hljs-number">1</span> }
{ <span class="hljs-string">"_id"</span> : <span class="hljs-number">2013</span>, <span class="hljs-string">"count"</span> : <span class="hljs-number">1</span> }
{ <span class="hljs-string">"_id"</span> : <span class="hljs-number">1984</span>, <span class="hljs-string">"count"</span> : <span class="hljs-number">1</span> }</code></pre>
<p>To drill down into just books by Arnold Schwarzenegger, you&#39;d need to add a
<code>$match</code> query.</p>
<pre><code class="language-javascript">db.books.aggregate([
  <span class="hljs-comment">// Just Arnold's books</span>
  { $match: { author: <span class="hljs-string">'Arnold Schwarzenegger'</span> } },
  <span class="hljs-comment">// Count the number of books published in a given year</span>
  {
    $group: {
      _id: <span class="hljs-string">'$year'</span>,
      count: { $sum: <span class="hljs-number">1</span> }
    }
  },
  <span class="hljs-comment">// Sort by year descending</span>
  { $sort: { count: <span class="hljs-number">-1</span>, _id: <span class="hljs-number">-1</span> } }
]);

<span class="hljs-comment">// Output</span>
{ <span class="hljs-string">"_id"</span> : <span class="hljs-number">2013</span>, <span class="hljs-string">"count"</span> : <span class="hljs-number">1</span> }
{ <span class="hljs-string">"_id"</span> : <span class="hljs-number">1984</span>, <span class="hljs-string">"count"</span> : <span class="hljs-number">1</span> }</code></pre>
<p>However, you need to execute a separate aggregation for every other facet.
For example, in MongoDB 3.2 there would be no good way to get both the
author counts and the year counts in a single aggregation. You&#39;d have to
execute the below aggregation separately to get the author counts.</p>
<pre><code class="language-javascript">db.books.aggregate([
  <span class="hljs-comment">// Count the number of books published in a given year</span>
  {
    $group: {
      _id: <span class="hljs-string">'$author'</span>,
      count: { $sum: <span class="hljs-number">1</span> }
    }
  },
  <span class="hljs-comment">// Sort by author name ascending</span>
  { $sort: { count: <span class="hljs-number">-1</span>, _id: <span class="hljs-number">1</span> } }
]);

<span class="hljs-comment">// Output</span>
{ <span class="hljs-string">"_id"</span> : <span class="hljs-string">"Arnold Schwarzenegger"</span>, <span class="hljs-string">"count"</span> : <span class="hljs-number">2</span> }
{ <span class="hljs-string">"_id"</span> : <span class="hljs-string">"Valeri Karpov"</span>, <span class="hljs-string">"count"</span> : <span class="hljs-number">2</span> }</code></pre>
<p>Furthermore, there
was no way to bucket books by price. The <code>$group</code> stage lets you count up
the number of books that cost $10 exactly, but there&#39;s no way to group books
by which ones are in the $10-$25 price range versus the $25-$50 range.
At <a href="https://www.crunchbase.com/organization/bookalokal-inc#/entity">BookaLokal</a> and <a href="https://www.crunchbase.com/organization/sixplus#/entity">SixPlus</a> we gave
up on using aggregation for this and just used a Node.js stream to count up
the different facets. However, <code>$facet</code> and <code>$bucket</code> make it possible to count
up facets in a single aggregation.</p>
<h2 id="introducing-facet-and-bucket">Introducing <code>$facet</code> and <code>$bucket</code></h2>
<p><code>$facet</code> is fundamentally an aggregation stage that executes
multiple aggregation pipelines in parallel and spits out the combined result
when the pipelines are all done. You can think of it as
<a href="http://caolan.github.io/async/docs.html#parallel"><code>async.parallel()</code></a> or <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all"><code>Promise.all()</code></a> for aggregation pipelines.</p>
<p>Sounds complicated, so here&#39;s a concrete example. Remember the 2 separate
aggregations for counting books by year and books by author? Here&#39;s the same
2 aggregations combined into a single aggregation with <code>$facet</code>. The
<code>$facet</code> stage lets you execute both pipelines in parallel and store the
output from both pipelines in a single document.</p>
<pre><code class="language-javascript">db.books.aggregate([
  {
    $facet: {
      <span class="hljs-comment">// The `years` property will be the output of the 'count by year' pipeline</span>
      years: [
        <span class="hljs-comment">// Count the number of books published in a given year</span>
        {
          $group: {
            _id: <span class="hljs-string">'$year'</span>,
            count: { $sum: <span class="hljs-number">1</span> }
          }
        },
        <span class="hljs-comment">// Sort by year descending</span>
        { $sort: { count: <span class="hljs-number">-1</span>, _id: <span class="hljs-number">-1</span> } }
      ],
      <span class="hljs-comment">// The `authors` property will be the output of the 'count by authors' pipeline</span>
      authors: [
        <span class="hljs-comment">// Count the number of books published in a given year</span>
        {
          $group: {
            _id: <span class="hljs-string">'$author'</span>,
            count: { $sum: <span class="hljs-number">1</span> }
          }
        },
        <span class="hljs-comment">// Sort by author name ascending</span>
        { $sort: { count: <span class="hljs-number">-1</span>, _id: <span class="hljs-number">1</span> } }
      ]
    }
  }
]);

<span class="hljs-comment">// Output</span>
{
    <span class="hljs-string">"years"</span> : [
        {
            <span class="hljs-string">"_id"</span> : <span class="hljs-number">2016</span>,
            <span class="hljs-string">"count"</span> : <span class="hljs-number">1</span>
        },
        {
            <span class="hljs-string">"_id"</span> : <span class="hljs-number">2015</span>,
            <span class="hljs-string">"count"</span> : <span class="hljs-number">1</span>
        },
        {
            <span class="hljs-string">"_id"</span> : <span class="hljs-number">2013</span>,
            <span class="hljs-string">"count"</span> : <span class="hljs-number">1</span>
        },
        {
            <span class="hljs-string">"_id"</span> : <span class="hljs-number">1984</span>,
            <span class="hljs-string">"count"</span> : <span class="hljs-number">1</span>
        }
    ],
    <span class="hljs-string">"authors"</span> : [
        {
            <span class="hljs-string">"_id"</span> : <span class="hljs-string">"Arnold Schwarzenegger"</span>,
            <span class="hljs-string">"count"</span> : <span class="hljs-number">2</span>
        },
        {
            <span class="hljs-string">"_id"</span> : <span class="hljs-string">"Valeri Karpov"</span>,
            <span class="hljs-string">"count"</span> : <span class="hljs-number">2</span>
        }
    ]
}</code></pre>
<p>One big advantage of using <code>$facet</code> is that you can combine <code>$match</code> with
<code>$facet</code>. If you execute a separate aggregation for every facet, you have to
execute the same <code>$match</code> query for every facet, which can be a lot of wasted
work. With <code>$facet</code>, you can execute <code>$match</code> once and use then <code>$facet</code>.</p>
<pre><code class="language-javascript">db.books.aggregate([
  <span class="hljs-comment">// Just Arnold's books</span>
  { $match: { author: <span class="hljs-string">'Arnold Schwarzenegger'</span> } },
  {
    $facet: { <span class="hljs-comment">/** same $facet stage as before */</span> }
  }
]);</code></pre>
<p>What about grouping by price? That&#39;s what the <code>$bucket</code> operator does for you.
Here&#39;s <code>$bucket</code> without <code>$facet</code>.</p>
<pre><code class="language-javascript">db.books.aggregate([
  {
    $bucket: {
      <span class="hljs-comment">// Bucket by price</span>
      groupBy: <span class="hljs-string">'$price'</span>,
      <span class="hljs-comment">// With 3 price ranges: [0, 10), [10, 25), [25, 50)</span>
      boundaries: [<span class="hljs-number">0</span>, <span class="hljs-number">10</span>, <span class="hljs-number">25</span>, <span class="hljs-number">50</span>]
    }
  }
]);

<span class="hljs-comment">// Output. The `_id` is the lower bound of the price range</span>
{ <span class="hljs-string">"_id"</span> : <span class="hljs-number">10</span>, <span class="hljs-string">"count"</span> : <span class="hljs-number">2</span> }
{ <span class="hljs-string">"_id"</span> : <span class="hljs-number">25</span>, <span class="hljs-string">"count"</span> : <span class="hljs-number">2</span> }</code></pre>
<p>If you don&#39;t care about setting up ranges manually, <code>$bucketAuto</code> will
automatically break your documents up into a specified number of buckets.</p>
<pre><code class="language-javascript">db.books.aggregate([
  {
    $bucketAuto: {
      <span class="hljs-comment">// Bucket by price</span>
      groupBy: <span class="hljs-string">'$price'</span>,
      <span class="hljs-comment">// And break it up into 2 buckets</span>
      buckets: <span class="hljs-number">2</span>
    }
  }
]);

<span class="hljs-comment">// Output. `_id` represents the range of each bucket</span>
{ <span class="hljs-string">"_id"</span> : { <span class="hljs-string">"min"</span> : <span class="hljs-number">10</span>, <span class="hljs-string">"max"</span> : <span class="hljs-number">32</span> }, <span class="hljs-string">"count"</span> : <span class="hljs-number">2</span> }
{ <span class="hljs-string">"_id"</span> : { <span class="hljs-string">"min"</span> : <span class="hljs-number">32</span>, <span class="hljs-string">"max"</span> : <span class="hljs-number">37</span> }, <span class="hljs-string">"count"</span> : <span class="hljs-number">2</span> }</code></pre>
<p>You can combine <code>$bucketAuto</code> with the established <code>$facet</code> query to get
counts for every facet:</p>
<pre><code class="language-javascript">db.books.aggregate([
  {
    $facet: {
      <span class="hljs-comment">// The `years` property will be the output of the 'count by year' pipeline</span>
      years: [<span class="hljs-comment">/* ... */</span>],
      <span class="hljs-comment">// The `authors` property will be the output of the 'count by authors' pipeline</span>
      authors: [<span class="hljs-comment">/* ... */</span>],
      price: [
        {
          $bucketAuto: {
            <span class="hljs-comment">// Bucket by price</span>
            groupBy: <span class="hljs-string">'$price'</span>,
            <span class="hljs-comment">// And break it up into 2 buckets</span>
            buckets: <span class="hljs-number">2</span>
          }
        }
      ]
    }
  }
]);

<span class="hljs-comment">// Output</span>
{
    <span class="hljs-string">"years"</span> : [<span class="hljs-comment">/* ... */</span>],
    <span class="hljs-string">"authors"</span> : [<span class="hljs-comment">/* ... */</span>],
    <span class="hljs-string">"price"</span> : [
        {
            <span class="hljs-string">"_id"</span> : {
                <span class="hljs-string">"min"</span> : <span class="hljs-number">10</span>,
                <span class="hljs-string">"max"</span> : <span class="hljs-number">32</span>
            },
            <span class="hljs-string">"count"</span> : <span class="hljs-number">2</span>
        },
        {
            <span class="hljs-string">"_id"</span> : {
                <span class="hljs-string">"min"</span> : <span class="hljs-number">32</span>,
                <span class="hljs-string">"max"</span> : <span class="hljs-number">37</span>
            },
            <span class="hljs-string">"count"</span> : <span class="hljs-number">2</span>
        }
    ]
}</code></pre>
<h2 id="facet-and-bucket-in-nodejs"><code>$facet</code> and <code>$bucket</code> in Node.js</h2>
<p>There are no version restrictions that I&#39;m aware of on using <code>$facet</code>,
<code>$bucket</code>, and <code>$bucketAuto</code> in mongodb and mongoose. The below scripts
work at least as far back as <code>mongodb@2.1.0</code> and <code>mongoose@4.5.0</code>:</p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> mongodb = <span class="hljs-built_in">require</span>(<span class="hljs-string">'mongodb'</span>);

mongodb.MongoClient.connect(<span class="hljs-string">'mongodb://localhost:27017/test'</span>).
  then(db =&gt; db.collection(<span class="hljs-string">'books'</span>).aggregate([
    {
      $facet: {
        <span class="hljs-comment">// The `years` property will be the output of the 'count by year' pipeline</span>
        years: [
          <span class="hljs-comment">// Count the number of books published in a given year</span>
          {
            $group: {
              _id: <span class="hljs-string">'$year'</span>,
              count: { $sum: <span class="hljs-number">1</span> }
            }
          },
          <span class="hljs-comment">// Sort by year descending</span>
          { $sort: { count: <span class="hljs-number">-1</span>, _id: <span class="hljs-number">-1</span> } }
        ],
        <span class="hljs-comment">// The `authors` property will be the output of the 'count by authors' pipeline</span>
        authors: [
          <span class="hljs-comment">// Count the number of books published in a given year</span>
          {
            $group: {
              _id: <span class="hljs-string">'$author'</span>,
              count: { $sum: <span class="hljs-number">1</span> }
            }
          },
          <span class="hljs-comment">// Sort by author name ascending</span>
          { $sort: { count: <span class="hljs-number">-1</span>, _id: <span class="hljs-number">1</span> } }
        ],
        price: [
          {
            $bucketAuto: {
              <span class="hljs-comment">// Bucket by price</span>
              groupBy: <span class="hljs-string">'$price'</span>,
              <span class="hljs-comment">// And break it up into 2 buckets</span>
              buckets: <span class="hljs-number">2</span>
            }
          }
        ]
      }
    }
  ]).toArray()).
  then(res =&gt; <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">JSON</span>.stringify(res, <span class="hljs-literal">null</span>, <span class="hljs-string">'  '</span>))).
  <span class="hljs-keyword">catch</span>(error =&gt; <span class="hljs-built_in">console</span>.error(<span class="hljs-string">'error'</span>, error));</code></pre>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> mongoose = <span class="hljs-built_in">require</span>(<span class="hljs-string">'mongoose'</span>);

mongoose.connect(<span class="hljs-string">'mongodb://localhost:27017/test'</span>);

<span class="hljs-keyword">var</span> Book = mongoose.model(<span class="hljs-string">'Book'</span>, <span class="hljs-keyword">new</span> mongoose.Schema());

Book.aggregate([
  {
    $facet: {
      <span class="hljs-comment">// The `years` property will be the output of the 'count by year' pipeline</span>
      years: [
        <span class="hljs-comment">// Count the number of books published in a given year</span>
        {
          $group: {
            _id: <span class="hljs-string">'$year'</span>,
            count: { $sum: <span class="hljs-number">1</span> }
          }
        },
        <span class="hljs-comment">// Sort by year descending</span>
        { $sort: { count: <span class="hljs-number">-1</span>, _id: <span class="hljs-number">-1</span> } }
      ],
      <span class="hljs-comment">// The `authors` property will be the output of the 'count by authors' pipeline</span>
      authors: [
        <span class="hljs-comment">// Count the number of books published in a given year</span>
        {
          $group: {
            _id: <span class="hljs-string">'$author'</span>,
            count: { $sum: <span class="hljs-number">1</span> }
          }
        },
        <span class="hljs-comment">// Sort by author name ascending</span>
        { $sort: { count: <span class="hljs-number">-1</span>, _id: <span class="hljs-number">1</span> } }
      ],
      price: [
        {
          $bucketAuto: {
            <span class="hljs-comment">// Bucket by price</span>
            groupBy: <span class="hljs-string">'$price'</span>,
            <span class="hljs-comment">// And break it up into 2 buckets</span>
            buckets: <span class="hljs-number">2</span>
          }
        }
      ]
    }
  }
]).
then(res =&gt; <span class="hljs-built_in">console</span>.log(res)).
<span class="hljs-keyword">catch</span>(error =&gt; <span class="hljs-built_in">console</span>.error(<span class="hljs-string">'error'</span>, error));</code></pre>
<p>Mongoose 4.8.0 will include a helper for <code>$facet</code> for its
<a href="http://mongoosejs.com/docs/api.html#aggregate-js">chainable aggregation pipeline builder</a>:</p>
<pre><code class="language-javascript">MyModel.aggregate().facet({
  field1: [<span class="hljs-comment">/* pipeline 1 */</span>],
  field2: [<span class="hljs-comment">/* pipeline 2 */</span>]
}).exec();</code></pre>
<h2 id="moving-on">Moving On</h2>
<p>MongoDB 3.4 has an incredible variety of new aggregation features, including
<code>$facet</code> and <a href="http://thecodebarbarian.com/a-nodejs-perspective-on-mongodb-34-graphlookup.html"><code>$graphLookup</code></a>. If you have graph data or an ecommerce search page, make
sure to upgrade to take advantage of these new features so you can delete
hundreds of lines of unnecessary code. Next week, I&#39;ll cover the new <a href="https://docs.mongodb.com/manual/tutorial/model-monetary-data/">decimal type</a>. The decimal type enables accurate base 10 arithmetic and avoids the <a href="https://en.wikipedia.org/wiki/Floating_point#Accuracy_problems">myriad fundamental flaws of floating point arithmetic</a>,
so you can finally stop copy/pasting <code>_.round(price, 2)</code>. </p>
</div><div style="color: #666666; border-top: 1px dashed #666666; margin: 25px; text-align: center; padding-top: 10px"><em>Found a typo or error? Open up a pull request! This post is
available as markdown on&nbsp;<a href="https://github.com/vkarpov15/thecodebarbarian.com/blob/master/lib/posts/#{post.src.substr('./lib/posts/'.length)}">Github</a></em></div><div id="disqus_thread"></div><script type="text/javascript">/* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
var disqus_shortname = 'codebarbarian'; // required: replace example with your forum shortname

/* * * DON'T EDIT BELOW THIS LINE * * */
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript><a class="dsq-brlink" href="http://disqus.com">comments powered by <span class="logo-disqus">Disqus</span></a></div></div><div style="padding-bottom: 100px">&nbsp;</div><script type="text/javascript">var xhr = new XMLHttpRequest();
xhr.open('POST', 'https://g0a3nbw0xa.execute-api.us-east-1.amazonaws.com/prod/track', true);
xhr.setRequestHeader('Content-Type', 'application/json');
xhr.onreadystatechange = function() {};
xhr.send(JSON.stringify({
  path: window.location.pathname,
  hostname: window.location.hostname
}));</script><link rel="stylesheet" href="/style/inlinecpc.css"></body></html>