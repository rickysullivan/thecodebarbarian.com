<!DOCTYPE html><html><head><script type="text/javascript">var _sf_startpt=(new Date()).getTime()
</script><title>The Importance of APIs in a Full Stack World | www.thecodebarbarian.com</title><meta name="viewport" content="width=device-width, initial-scale=1"><link href="//maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap.min.css" rel="stylesheet" type="text/css"><link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:200,300,400,600" rel="stylesheet" type="text/css"><link href="//fonts.googleapis.com/css?family=Merriweather:400,400italic,600,700" rel="stylesheet" type="text/css"><link href="//maxcdn.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet"><link href="/style/style.css" rel="stylesheet" type="text/css"><link href="/style/github.css" rel="stylesheet" type="text/css"><script href="http://code.jquery.com/jquery-2.1.1.min.js" type="text/javascript"></script><script href="//maxcdn.bootstrapcdn.com/bootstrap/3.2.0/js/bootstrap.min.js" type="text/javascript"></script><script href="/javascript/sidebar.js" type="text/javascript"></script><meta property="og:title" content="The Importance of APIs in a Full Stack World"><meta property="og:url" content="http://www.thecodebarbarian.com/importance-of-apis-in-a-full-stack-world"><meta property="og:image" content="http://i.imgur.com/y6qzPpc.png"><meta property="og:site_name" content="The Code Barbarian"><meta property="description" content="*This article originally appeared on [LunchBadger](https://www.lunchbadger.com/go-full-stack-with-express-and-apis/). LunchBadger [helps you build APIs in a continuous lifecycle using serverless open source](https://www.lunchbadger.com/development/).*"><meta name="twitter:image" content="http://i.imgur.com/y6qzPpc.png"></head><body><div class="navbar social-links hidden-sm hidden-xs"><div class="container"><ul class="nav navbar-nav navbar-right"><li><a href="http://www.twitter.com/code_barbarian">twitter</a></li><li><a href="http://www.github.com/vkarpov15">github</a></li><li><a href="http://thecodebarbarian.com/feed.xml">rss</a></li><li><a href="/recommendations">recommendations</a></li></ul></div></div><div class="navbar" id="nav"><div class="container"><div class="navbar-header"><a class="navbar-brand big-brand" href="http://thecodebarbarian.com"><img class="logo" src="/images/Barbarian_Head.png"><span class="site-name">The Code Barbarian</span></a></div><div class="navbar-right collapse navbar-collapse" id="home-nav-mobile"><ul class="nav navbar-nav"><li><a href="/tag/mongodb.html">MongoDB</a></li><li><a href="/tag/nodejs.html">NodeJS</a></li><li><a href="/tag/asyncawait.html">Async/Await</a></li><li><a href="/tag/vue.html">Vue</a></li><li class="hidden-md hidden-lg"><a href="#">@code_barbarian</a></li><li class="hidden-md hidden-lg"><a href="#">TCB Github</a></li><li class="hidden-md hidden-lg"><a href="#">TCB Facebook</a></li></ul></div></div></div><div class="container-fluid"><div class="col-lg-3 col-lg-offset-9 right-bar" id="desktop-right-bar"><div class="right-bar-content-slider pull-right"><div class="row recent-posts right-bar-group"><div class="col-lg-12 articles"><p class="right-bar-label">Most Popular Articles</p><ul class="list-unstyled"><li class="right-bar-li"><a href="/common-async-await-design-patterns-in-node.js.html">Common Async/Await Design Patterns in Node.js</a></li><li class="right-bar-li"><a href="/unhandled-promise-rejections-in-node.js.html">Unhandled Promise Rejections in Node.js</a></li><li class="right-bar-li"><a href="/using-async-await-with-mocha-express-and-mongoose">Using Async/Await with Mocha, Express, and Mongoose</a></li><li class="right-bar-li"><a href="/write-your-own-node-js-promise-library-from-scratch.html">Write Your Own Node.js Promise Library from Scratch</a></li><li class="right-bar-li"><a href="/80-20-guide-to-express-error-handling">The 80/20 Guide to Express Error Handling</a></li></ul></div></div><div class="row recent-posts right-bar-group"><div class="col-lg-12 books"><p class="right-bar-label">Ebooks<div><a href="http://asyncawait.net/?utm_source=thecodebarbarian&amp;utm_campaign=sidebar"><img src="/images/verticalbanner.png"></a></div><div><a href="http://es2015generators.com"><img src="https://i.imgur.com/xvGNKlr.png"><p><i>The 80/20 Guide to ES2015 Generators</i></p></a></div></p></div></div></div></div></div><div class="container-fluid hidden-sm hidden-md hidden-lg" id="mobile-sharing-options"><div class="row"><div class="col-lg-12"><style>#home-nav-mobile {
  float: left !important;
  margin-left: 215px !important;
}
</style><div class="post-sharing-options"><div class="row"><div class="col-xs-3 twitter-share sharing-option"><a class="social" href="https://twitter.com/share?url=#{encodeURIComponent('http://www.thecodebarbarian.com' + post.dest.directory.substr('./bin'.length) + '/' + post.dest.name)}&amp;via=code_barbarian"><i class="fa fa-twitter"></i></a></div><div class="col-xs-3 facebook-share sharing-option"><a class="social" href="https://www.facebook.com/sharer/sharer.php?u=#{encodeURIComponent('http://www.thecodebarbarian.com/' + post.dest.directory.substr('./bin'.length) + '/' + post.dest.name)}"><i class="fa fa-facebook"></i></a></div><div class="col-xs-3 google-share sharing-option"><a class="social" href="https://plus.google.com/share?url=#{encodeURIComponent('http://www.thecodebarbarian.com/' + post.dest.directory.substr('./bin'.length) + '/' + post.dest.name)}"><i class="fa fa-google-plus"></i></a></div><div class="col-xs-3 comment sharing-option"><a class="social" href="#disqus_thread"><i class="fa fa-comment"></i></a></div></div></div></div></div></div><div class="post-sharing-options hidden-xs pull-left" id="desktop-sharing-options"><ul class="list-unstyled"><li class="twitter-share"><a class="social" href="https://twitter.com/share?url=#{encodeURIComponent('http://www.thecodebarbarian.com' + post.dest.directory.substr('./bin'.length) + '/' + post.dest.name)}&amp;via=code_barbarian"><i class="fa fa-twitter sharing-option"></i></a></li><li class="facebook-share"><a class="social" href="https://www.facebook.com/sharer/sharer.php?u=#{encodeURIComponent('http://www.thecodebarbarian.com/' + post.dest.directory.substr('./bin'.length) + '/' + post.dest.name)}"><i class="fa fa-facebook sharing-option"></i></a></li><li class="google-share"><a class="social" href="https://plus.google.com/share?url=#{encodeURIComponent('http://www.thecodebarbarian.com/' + post.dest.directory.substr('./bin'.length) + '/' + post.dest.name)}"><i class="fa fa-google-plus sharing-option"></i></a></li></ul></div><div class="container"><div class="col-lg-9 post-text"><div class="row"><div class="title-byline-container"><h1 class="post-title">The Importance of APIs in a Full Stack World</h1><div class="credits"><span class="byline">by Valeri Karpov</span><span class="byhandle"><a href="http://www.twitter.com/code_barbarian">@code_barbarian</a></span><span class="bydate">July 28, 2017</span></div></div></div><script type="text/javascript" src="/js/native.js"></script><div><script src="//m.servedby-buysellads.com/monetization.js" type="text/javascript"></script>

<div class="native-banner"></div>
</div><script async type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CKYI5K3Y&placement=thecodebarbariancom" id="_carbonads_js"></script><div class="post-body-text-container"><p><em>This article originally appeared on <a href="https://www.lunchbadger.com/go-full-stack-with-express-and-apis/">LunchBadger</a>. LunchBadger <a href="https://www.lunchbadger.com/development/">helps you build APIs in a continuous lifecycle using serverless open source</a>.</em></p>
<p>Around 2011-2014, the notion of a full stack JavaScript developer became mainstream. The idea was that, as browsers became more standardized, hybrid native app frameworks like Cordova grew in sophistication, and Node.js continued to grow in popularity, we would all be working on independent small JavaScript projects that each had their own client, server, and database. However, increasing fragmentation in the client-side JavaScript space, the continued superiority of native mobile apps over hybrid mobile apps, and the power of specialization has drastically slowed the rise of full stack JavaScript.</p>
<p>Now that the promise of a single unified client is no longer an imminent possibility, APIs, REST and otherwise, are more pivotal than ever for unifying disparate clients. Node.js&#39; powerful concurrency model along with the prolific npm and <a href="https://www.npmjs.com/package/express">Express</a> ecosystems make Express the ideal tool to build your next API.</p>
<h2 id="shouldnt-we-all-just-be-using-firebase">Shouldn&#39;t We All Just Be Using Firebase?</h2>
<p>There was a time when I thought AngularFire meant the end of backend development. Firebase&#39;s client library maintained a socket connection to a realtime database, and, best of all, AngularFire integrated with Angular 1&#39;s dirty checking to sync your changes in JavaScript to the realtime database with no work on your part. All you did was write some HTML and you&#39;re done. Add in over-the-air updates with Ionic 1 and you had a mobile app too.</p>
<pre><code class="language-javascript">app.controller(<span class="hljs-string">'MyController'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">$scope, $firebaseObject</span>) </span>{
  <span class="hljs-keyword">var</span> ref = firebase.database().ref();
  $scope.data = $firebaseObject(ref);
});</code></pre>
<pre><code class="language-html">&lt;div controller=&quot;MyController&quot;&gt;
  &lt;h1&gt;{{data.title}}&lt;/h1&gt;
&lt;/div&gt;</code></pre>
<p>Unfortunately, it also became clear that Angular 1 was difficult to optimize and extend beyond building simple forms. Cordova&#39;s proving to have similar issues. Sophisticated clients require developers to specialize.</p>
<p>With the assumption that you need disparate clients, like an iOS app, an Android app, an Electron desktop app, and a web client, you need a centralized logic layer. If you use a realtime database directly and your Android app&#39;s logic doesn&#39;t keep up with your iOS app&#39;s logic, you&#39;ve got a problem. That&#39;s where APIs come in.</p>
<h2 id="what-should-apis-do">What Should APIs Do?</h2>
<p>I think KeenIO summed it up best when they said APIs <a href="https://blog.keen.io/the-api-era-f004f6800488">&quot;boil complex processes down to simple commands that magically do lots of work for you.&quot;</a> Or, like <a href="https://twitter.com/browserling/status/866694093929316352">Browserling put it</a>, an API is like a Kraken that lurks under the surface of your apps and ties together logic and data sources so your apps don&#39;t have to. Here&#39;s a few examples of tasks that APIs should take care of for their clients.</p>
<img src="https://pbs.twimg.com/media/DAcdpz-WsAIczvd.jpg">

<ul>
<li>Security</li>
</ul>
<p>Clients are wildly insecure, as I was recently reminded when I booked a blocked-off slot for car maintenance because the dealer&#39;s site relied on Angular 1 form validation. They didn&#39;t verify the slot was available on their server. <a href="http://expressjs.com/en/guide/writing-middleware.html">Express middleware</a> makes it easy to define security rules for a group of routes without repeating yourself. For example, the <a href="https://www.npmjs.com/package/express-jwt">express-jwt</a> library makes it easy to set up <a href="https://jwt.io/">JSON Web Token</a> authentication. You can write additional middleware to define your own custom rules.</p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> app = <span class="hljs-built_in">require</span>(<span class="hljs-string">'express'</span>)();
<span class="hljs-keyword">const</span> bodyParser = <span class="hljs-built_in">require</span>(<span class="hljs-string">'body-parser'</span>);

<span class="hljs-keyword">const</span> jwt = <span class="hljs-built_in">require</span>(<span class="hljs-string">'express-jwt'</span>)({ secret: <span class="hljs-string">'my secret key'</span> });

<span class="hljs-comment">// Now all HTTP endpoints that start with `/admin` and `/user`</span>
<span class="hljs-comment">// require JWT authentication</span>
app.use(<span class="hljs-string">'/admin'</span>, jwt);
app.use(<span class="hljs-string">'/user'</span>, jwt);

<span class="hljs-comment">// Add an additional layer of security to `/admin` endpoints to</span>
<span class="hljs-comment">// make sure only admin users reach it</span>
app.use(<span class="hljs-string">'/admin'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">req, res, next</span>) </span>{
  <span class="hljs-comment">// `express-jwt` sets `req.user` for you. Conceptually, jwt's</span>
  <span class="hljs-comment">// encrypt the JSON representation of the user using the secret key.</span>
  <span class="hljs-comment">// In other words, your access token for the API is your encrypted</span>
  <span class="hljs-comment">// user data!</span>
  <span class="hljs-keyword">if</span> (!req.user.isAdmin) {
    <span class="hljs-keyword">return</span> res.status(<span class="hljs-number">401</span>).json({ err: <span class="hljs-string">'Must be admin!'</span> });
  }
  <span class="hljs-keyword">return</span> next();
});</code></pre>
<ul>
<li>Concurrency and Locking</li>
</ul>
<p>I&#39;m sure you&#39;ve heard that Node.js is non-blocking and there&#39;s no standard Node.js notion of a &quot;lock&quot;, as opposed to languages like <a href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/locks/Lock.html?is-external=true">Java</a>. However, these days APIs are typically scaled horizontally, either across multiple instances of an API server or across numerous microservices. When you have multiple servers on different machines, the standard in-memory locks you might remember from undergrad systems programming are not very useful. You need <a href="https://redis.io/topics/distlock">distributed locking</a>, and managing distributed locking across different clients is a nightmare.</p>
<p>Express middleware makes it easy to lock a resource for a certain group of endpoints. A common example is locking a user every time the client hits an endpoint that updates a user. You might have separate endpoints like <code>updateAdmin</code> for doing special types of updates, so in general you&#39;d like to
lock the user every time someone hits a <code>PUT</code> endpoint under <code>/user</code>. Here&#39;s an example using MongoDB as the store for the distributed lock.</p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> { MongoClient } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'mongodb'</span>);
<span class="hljs-keyword">const</span> app = <span class="hljs-built_in">require</span>(<span class="hljs-string">'express'</span>)();
<span class="hljs-keyword">const</span> bodyParser = <span class="hljs-built_in">require</span>(<span class="hljs-string">'body-parser'</span>);

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">run</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> db = <span class="hljs-keyword">await</span> MongoClient.connect(<span class="hljs-string">'mongodb://localhost:27017/test'</span>);

  app.put(<span class="hljs-string">'/user/:id/*'</span>, <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req, res, next</span>) </span>{
    <span class="hljs-comment">// If we successfully upserted, that means we acquired the lock. Otherwise,</span>
    <span class="hljs-comment">// means the resource is already locked</span>
    <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> db.collection(<span class="hljs-string">'Lock'</span>).findOneAndUpdate(
      { resource: <span class="hljs-string">'User'</span>, id: req.params.id },
      { $setOnInsert: { createdAt: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>() } },
      { upsert: <span class="hljs-literal">true</span>, returnOriginal: <span class="hljs-literal">false</span> });

    <span class="hljs-keyword">if</span> (!result.lastErrorObject.updatedExisting) {
      <span class="hljs-comment">// Acquired the lock!</span>

      res.on(<span class="hljs-string">'finish'</span>, () =&gt; {
        <span class="hljs-comment">// Release the lock by deleting the lock document when the request</span>
        <span class="hljs-comment">// handler is done</span>
        db.collection(<span class="hljs-string">'Lock'</span>).deleteOne({ _id: result.value._id });
      });
      <span class="hljs-keyword">return</span> next();
    }

    res.status(<span class="hljs-number">409</span>).json({ error: <span class="hljs-string">`Resource <span class="hljs-subst">${req.params.id}</span> locked`</span> });
  });

  app.put(<span class="hljs-string">'/user/:id/updateAdmin'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) </span>{
    res.json({ ok: <span class="hljs-number">1</span> });
  });

  app.put(<span class="hljs-string">'/user/:id/update'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) </span>{
    res.json({ ok: <span class="hljs-number">1</span> });
  });

  app.listen(<span class="hljs-number">3000</span>);
}

run().catch(error =&gt; <span class="hljs-built_in">console</span>.error(error.stack));</code></pre>
<ul>
<li>Data Validation</li>
</ul>
<p>Data formats change fast, and apps can&#39;t keep up unless you force upgrade your users regularly. Thankfully, because JavaScript is a dynamically typed language, the JavaScript community has a myriad of well-adopted type casting and data validation libraries, including <a href="http://npmjs.org/package/mongoose">mongoose</a>, <a href="https://www.npmjs.com/package/joi">joi</a>, <a href="https://www.npmjs.com/package/ajv">ajv</a>, and others.  <a href="http://expressjs.com/en/guide/error-handling.html">Express error handling middleware</a> enables you to handle data validation errors in a standard way across your application.</p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> Joi = <span class="hljs-built_in">require</span>(<span class="hljs-string">'joi'</span>);
<span class="hljs-keyword">const</span> { MongoClient } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'mongodb'</span>);
<span class="hljs-keyword">const</span> app = <span class="hljs-built_in">require</span>(<span class="hljs-string">'express'</span>)();
<span class="hljs-keyword">const</span> bodyParser = <span class="hljs-built_in">require</span>(<span class="hljs-string">'body-parser'</span>);

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">run</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> db = <span class="hljs-keyword">await</span> MongoClient.connect(<span class="hljs-string">'mongodb://localhost:27017/test'</span>);
  <span class="hljs-comment">// `schema` lets you validate that objects match the given schema</span>
  <span class="hljs-keyword">const</span> schema = Joi.object().keys({
    email: Joi.string().required().regex(<span class="hljs-regexp">/^.+@.+\..+$/</span>),
    name: Joi.string().required()
  });

  <span class="hljs-comment">// Express body parser</span>
  app.use(bodyParser.json());
  <span class="hljs-comment">// Sample endpoint that inserts a user in the database if it is valid</span>
  app.post(<span class="hljs-string">'/user'</span>, <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req, res, next</span>) </span>{
    <span class="hljs-keyword">const</span> result = schema.validate(req.body);
    <span class="hljs-keyword">if</span> (result.error) {
      <span class="hljs-keyword">return</span> next(result.error);
    }
    <span class="hljs-keyword">await</span> db.collection(<span class="hljs-string">'User'</span>).insertOne(req.body);
    <span class="hljs-keyword">return</span> { user: req.body };
  });
  <span class="hljs-comment">// Express error handling middleware. Will execute if an error was passed to</span>
  <span class="hljs-comment">// `next()`. When you add more endpoints, they will still have the same</span>
  <span class="hljs-comment">// way of reporting errors.</span>
  app.use(<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err, req, res, next</span>) </span>{
    <span class="hljs-keyword">if</span> (err.isJoi) {
      <span class="hljs-keyword">return</span> res.status(<span class="hljs-number">400</span>).json({ err: err.message, details: err.details });
    }
    next(err);
  });
  <span class="hljs-comment">// Catch-all error handler</span>
  app.use(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err, req, res, next</span>) </span>{
    <span class="hljs-keyword">return</span> res.status(<span class="hljs-number">500</span>).json({ err: err.message });
  });

  app.listen(<span class="hljs-number">3000</span>);
}

run().catch(error =&gt; <span class="hljs-built_in">console</span>.error(error.stack));</code></pre>
<ul>
<li>Interfacing With Externally Facing APIs</li>
</ul>
<p>For both security and maintainability, APIs should be responsible for most interactions between your software and external APIs. Leveraging external APIs is difficult and error prone, having a centralized layer for communicating with external APIs and reporting errors is critical. Keeping potentially sensitive API keys out of the hands of insecure clients is also important.</p>
<p>Express error handling middleware makes it easy to handle errors from external APIs in a standardized way, so long as the errors are reported through <code>next()</code>. Here&#39;s an example of error handling middleware for the Twilio API.</p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> Twilio = <span class="hljs-built_in">require</span>(<span class="hljs-string">'twilio'</span>);
<span class="hljs-keyword">const</span> app = <span class="hljs-built_in">require</span>(<span class="hljs-string">'express'</span>)();

<span class="hljs-keyword">const</span> twilio = <span class="hljs-keyword">new</span> Twilio(process.env.TWILIO_ACCOUNT_SID, process.env.TWILIO_AUTH_TOKEN);

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">run</span>(<span class="hljs-params"></span>) </span>{
  app.post(<span class="hljs-string">'/sms'</span>, <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req, res, next</span>) </span>{
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">await</span> twilio.messages.create({
        body: <span class="hljs-string">'Hello'</span>,
        <span class="hljs-comment">// From number is invalid, this will cause an error</span>
        <span class="hljs-keyword">from</span>: <span class="hljs-string">'+12015550123'</span>,
        to: <span class="hljs-string">'+5555555555'</span>
      });
    } <span class="hljs-keyword">catch</span> (error) {
      <span class="hljs-comment">// Mark this error as a Twilio error, because the Twilio API doesn't</span>
      <span class="hljs-comment">// have a canonical error class</span>
      error.isTwilio = <span class="hljs-literal">true</span>;
      <span class="hljs-keyword">return</span> next(error);
    }
    res.json({ ok: <span class="hljs-number">1</span> });
  });

  <span class="hljs-comment">// Express error handler for handling twilio errors</span>
  app.use(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err, req, res, next</span>) </span>{
    <span class="hljs-keyword">if</span> (err.isTwilio) {
      <span class="hljs-comment">// Handle Twilio errors from all endpoints</span>
      <span class="hljs-keyword">return</span> res.status(err.status).json({ err: <span class="hljs-string">`Twilio error: <span class="hljs-subst">${err.message}</span>`</span> });
    }
    next(err);
  });

  <span class="hljs-comment">// Catch-all error handler</span>
  app.use(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err, req, res, next</span>) </span>{
    <span class="hljs-keyword">return</span> res.status(<span class="hljs-number">500</span>).json({ err: err.message });
  });

  app.listen(<span class="hljs-number">3000</span>);
}

run().catch(error =&gt; <span class="hljs-built_in">console</span>.error(error.stack));</code></pre>
<h2 id="moving-on">Moving On</h2>
<p>Because clients are becoming increasingly specialized, APIs are becoming increasingly important for providing consistency across wildly different clients. The 2013 dream of a single unified JavaScript client for mobile, browser, and desktop is infeasible for most companies. But, because of the prolific npm ecosystem, Node.js&#39; elegant concurrency model, and code sharing with browser, <a href="https://electron.atom.io/">Electron</a>, and <a href="https://facebook.github.io/react-native/">React Native</a>, a Node.js API written in Express is still the way to go.</p>
</div><div style="color: #666666; border-top: 1px dashed #666666; margin: 25px; text-align: center; padding-top: 10px"><em>Found a typo or error? Open up a pull request! This post is
available as markdown on&nbsp;<a href="https://github.com/vkarpov15/thecodebarbarian.com/blob/master/lib/posts/#{post.src.substr('./lib/posts/'.length)}">Github</a></em></div><div id="disqus_thread"></div><script type="text/javascript">/* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
var disqus_shortname = 'codebarbarian'; // required: replace example with your forum shortname

/* * * DON'T EDIT BELOW THIS LINE * * */
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript><a class="dsq-brlink" href="http://disqus.com">comments powered by <span class="logo-disqus">Disqus</span></a></div></div><div style="padding-bottom: 100px">&nbsp;</div><script type="text/javascript">var xhr = new XMLHttpRequest();
xhr.open('POST', 'https://g0a3nbw0xa.execute-api.us-east-1.amazonaws.com/prod/track', true);
xhr.setRequestHeader('Content-Type', 'application/json');
xhr.onreadystatechange = function() {};
xhr.send(JSON.stringify({
  path: window.location.pathname,
  hostname: window.location.hostname
}));</script><link rel="stylesheet" href="/style/inlinecpc.css"></body></html>